### Особенности построения приложений и сервисов

#### От Web-приложения, к Web-сервису

Подведем промежуточный итог предыдущих рассмотрений. Вернемся к начальному шаблону web, вот он:
```
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.MapGet("/", () => "Hello World!");
app.Run();
```
Теперь посмотрим на него с учетом того, что мы дополнительно узнали. Вспоминаем что это за программа. Две первых строчки носят технический характер, на них не обращаем внимание. Третья строка - самая главная, в ней задается как запрос (request) преобразуется в результат (response). В ней определяется вход в обработку, передаваемые параметры, формируемый результат. Предполагается, что некоторый внешний, возможно удаленный, клиент делает запрос к приложению. Приложение опознает запрос по входу (в приведенном примере "/"). В запросе возможно есть параметры, но в приведенном примере их нет. Задачей приложения, получившего запрос, заключается в том, чтобы вычислить и выдать некоторый результат. 

Отбрасывая лишние для нас возможности, перепишем шаблон в несколько расширенном виде:
```
var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); // начальные строчки

app.MapGet("/entry", (HttpRequest request) => Transform(request));
//           вход             запрос            преобразование 
app.Run(); // запуск приложения
```
В начальном варианте для вычисления результата объект запроса не требовался, но в других ситуациях он нужен. Причем не только для получания параметров запроса, но и для разных других "дел" организации взаимодействия по HTTP. Заметим, что определений app.MapGet() может быть несколько. В простом варианте они отличаются идентификатором entry. Соответственно запросы от клиентов будут http://domain/AppName/entry{параметры}, http://domain/AppName/entry2{параметры}, ...

Для каждого входа надо определить преобразование (в шаблоне, это функция Transform) параметры которой будут браться из запроса. Как уже указывалось, задача функции - выработать некоторый результат для возврата клиенту. В принципе, результат, как правило, является MIME-результатом. Детали этой классификации довольно сложны, нам важно следующее:
1) Разные MIME типы результатов определяются строкой ContentType, есть фиксированое количество таких типов. Примеры "text/html", "image/jpeg".
2) Результат может быть текстовым и может быть бинарным. Текстовые результаты: "text/plain", "text/xml", "text/html", "text/json". Бинарные результаты: "image/jpeg", "video/mp4", "audio/mp3", "application/pdf".
3) "Встраивание" результата в выходной поток response происходит разным способом. Вычисленный объект должен иметь тип Microsoft.AspNetCore.Http.Results. Там есть множество вариантов результата, включая и текстовые и бинарные и указание на ошибочную ситуацию и перенаправление (redirect).

В рамках нашего обучения и творческого проекта, предлагается два базовых способа формирования результата:
```
Results.Content({формирователь текста}, "text/...") // для текстовых результатов
Results.File("photos/1000-0.jpg", "image/jpeg") // для бинарный файлов фото, видео и т.д. (нужно сменить contantType)
```      
Теперь обязательно надо закрепить изученное. Задание: напишите приложение, которое содержит описание нескольких входов таких, что выдаются плоский текст, html-текст, xml-текст, json-текст, фотографию, видео, аудио, PDF-файл. Вам кажется, что это вы уже делали, тем не менее, начните с генерации шаблона web и далее старайтесь пореже заглядывать в инструкции мастеров, свои старые тексты и  шапаргалки. Впрочем последнее - не обязательно. Если вы самостоятельно сделали шпаргалку, то ей можно и нужно пользоваться.  

Теперь посмотрим на результат. Мы делали Web-приложение, а сделали сервисы! Web-приложение - только вход, порождающий HTML. В чем отличие? Отличие в том, кто или что является потребителем программы. Если это человек, ему удобнее читать гипертекстовую композицию. Если это программа, то для программы важна структурированность и полнота информации. Простым (плоским) текстом трудно реализовать полноту информации, а также ее структуризацию. Мультимедиа могут давать красивую картинку, но без текстовых пояснений, списков, таблиц и гиперссылок, полноты добиться трудно.

#### Рассширенные параметры запроса 

Ранее, мы уже получали параметры строки запроса с помощью request.Query[]
```
app.MapGet("/a", (HttpRequest request) =>
{
    var x = request.Query["x"];
    var y = request.Query["y"];
    return $"Hello {x} и {y}!";
});
```
Это актуально для строки `http://localhost:5167/a?x=1&y=qqq`, но как передачу параметров можно сделать иначе? 

Можно передать параметры с помощью маршрута, напр. `http://localhost:5167/entry/1/qqq`. Маршрутом называтся цепочка значений, разделенная символом '/' (слэш), как в файловой системе (директория/поддиректория/../файл, только это более динамическая конструкция). Это позволит нам создавать разного рода страницы в зависимости от переданных параметров. Давайте это реализуем.
```
app.MapGet("/entry/{x}/{y}", (int x, String y) => $"Ваши параметры: \nЦелое {x} \nСтрока {y}");
``` 
Символ `\n` обозначает перенос строки. 

Как можно заметить, мы передаем x - целое число, а что будет, если передать строку? Случится ошибка, попробуйте.

Такой странный способ передачи параметров может показаться ненужным, однако он используется довольно часто. Все дело в REST. Что означает эта аббревиатура нам не важно, пользоваться REST мы, скорее всего, не будем, однако полезно посмотреть на виды запросов этой группы:
```
GET http://www.example.com/api/v1.0/users (вернуть список пользователей) 
GET http://www.example.com/api/v1.0/users/12345 (вернуть данные о пользователе с id 12345) 
GET http://www.example.com/api/v1.0/users/12345/orders 
PUT http://www.example.com/api/v1.0/users/12345 (обновить данные пользователя с id 12345) 
PUT http://www.example.com/api/v1.0/users/12345/orders/98765 (обновить данные заказа с id 
98765 для пользователя с id 12345) 
POST http://www.example.com/api/v1.0/customers (создать новый ресурс в разделе customers) 
POST http://www.example.com/api/v1.0/customers/12345/orders (создать заказ для ресурса с id 
12345) 
DELETE http://www.example.com/api/v1.0/customers/12345 (удалить из customers ресурс с id 12345) 
DELETE http://www.example.com/api/v1.0/customers/12345/orders/21 (удалить у ресурса с id 12345 
заказ с id 21)
```
Опять же первое слово в запросе будем считать комментарием. Видно, что в адресной строке задается цепочка параметров, напр. users/12345/orders, что означает какую-то манипуляцию (взять, положить, послать, уничтожить) c единичным объектом какого-то класса или со всем классом/подклассом. 

#### Источник данных
Если мы имеем дело с сервисом, отвечающим на запросы, то он, как правило, оссновывается на источнике данных. Имеется ввиду множество структурированных данных или база данных, которые сервис использует для ответа на запросы. Примеров может быть множество: файлы разной структуры, SQL базы данных, сервисы, репозитории и др. 

Источник данных является существенным звеном в канонической трехзвенной клиент-серверной архитектуры. Сложились стереотипы реализации реализации такой архитектуры, главный из который является SQL база данных. Однако, такое решение вносит сложность и громоздкость в проект, тогда как в конкретных случаях более эффективной являются другая организация данных. Или вообще, источник данных уже задан и он вовсе не SQL-евский. К радости наших учеников, SQL мы изучать и применять не будем. Сейчас посмотрим на разные возможности. 

Почти всегда взаимодействие с данными, можно поместить в отдельный объект какого-то класса. Этот класс часто называют контроллером. Контроллер выполняет роль "переходника" между данными и функцией формирования результата. Это достигается созданием подходящих методов доступа. Кроме того, контроллер имеет возможность быть иницализированным в начале работы сервиса/приложения через запуск и исполнение конструктора. 

Удобство использование контроллера подчеркнем тем, что расширим шаблон канонического сервиса:
```
var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); // начальные строчки

Controller1 cont1 = new Controller1(параметры конструктора);
app.MapGet("/entry1", (HttpRequest request) => Transform1(request, cont1));

Controller2 cont2 = new Controller2(параметры конструктора);
app.MapGet("/entry2", (HttpRequest request) => Transform2(request, cont2));

// ... Другие входы

app.Run(); // запуск приложения

class Conroller1
{
    // Конструктор и методы
}
class Conroller2
{
    // Конструктор и методы
}
// Другие нужные контроллеры
```
Итак, выводы: общая схема рекомендуемого построения приложения или сервиса заключается в 1) определении набора реализуемых входов; 2) для каждого входа определяется набор параметров; 3) для входов, требующих контроллера, определяется класс, который будет этим контроллером; 4) создание и инициирование контроллеров осуществляется перед определением (или внутри) функции преобразования для соответствующих входов. 
 
#### Пример приложения с простым источником данных
Пусть источником данных в примере будет очень простая база данных: множество персон и их телефоны. Мы хотим простейшего решения, тогда и контроллер будет простейший, напр. это будет массив записей, с полями name и phone. Нам потребуется один вход и, соответственно, один конроллер. Параметров у входа не будет. Смысл запроса по данному входу будет выдача всех персон с их телефонами. Пишем по шаблону:
```
var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); // начальные строчки

PersConroller cont1 = new PersConroller();
Func<HttpRequest, IResult> Transform = (request) => Results.Text($@"
<!DOCTYPE html>
<html>
    <head> <meta charset='utf-8'/> </head>
    <body>
        <h1>Привет!</h1>
        {cont1.persons
            .Select(p => $"<div>{p.name} {p.phone}</div>")
            .Aggregate((sum, s) => sum + s)}
    </body>
</html>
", "text/html");

app.MapGet("/", Transform);

app.Run(); // запуск приложения

public class Pers { public string name, phone; public Pers(string na, string ph) { name = na; phone = ph; } }
public class PersConroller
{
    public Pers[] persons = new Pers[]
    {
        new Pers("Иванов Иван Иванович", "777-7777"),
        new Pers("Петров Петр Петрович", "123-4567"),
        new Pers("Сидоров Сидор Сидорович", "555-1234")
    };
}
```

#### API взаимодействие
Давайте попробуем вызвать одну страницу из другой. Точнее, приложение вызовет сервис или сервис вызовет другой сервис. 

Допустим, у нас есть пользователи и каждый пользователь обладает какой-либо информацией. Для простоты оставим только имя. Давайте реализуем доступ к информации о пользователях.
```
app.MapGet("/user/{id}", (int id) => Results.Content(Users.GetUser(id), "text/json"));
```
Теперь давайте реализуем `Users.GetUser(id)`, которая будет получать информацию о пользователях. 
```
public static class Users //  Создаем статический класс. В другом файле, создайте classes.cs, в котором будут храниться классы.
{
    public static string GetUser(int id) // Получение информации.
    {
        if (id == 1234)
        {
            return "Ivan";
        }else if (id == 1233)
        {
            return "Vasya";
        }
        return "";
    }
}
``` 
Метод API уже есть. Можете запустить программу с помощью `dotnet run` или `dotnet watch` (`dotnet watch` обновляет вашу программу сразу при изменении файлов)
Перейдите по ссылке `http://localhost:5042/user/1234` (замените `5042` своим портом). 
Появилось имя - `Ivan`. API работает!

Сейчас у нас есть только 2 пользователя. Представим, что мы не знаем их ID (знаем только диапазон - от 1230 до 1235). Давайте опросим наш API об информации о пользователях.
```
app.MapGet("/users/", async (HttpRequest request) =>
{
    string html = "<ul>";
    HttpClient client = new HttpClient(); // создаем клиент для отправки запроса
    for (int i = 1230; i < 1236; i++)
    {
        string Url = request.Headers["Host"]; // считываем адрес localhost
        HttpResponseMessage response = await client.GetAsync($"http://{Url}/user/{i}"); // отправляем запрос асинхронно 
        string json = await  response.Content.ReadAsStringAsync(); // читаем ответ также асинхронно
        html += $"<li>{json}</li>"; // вставляем в html
    }
    html += "</ul>";
    return Results.Content(html, "text/html"); // выводим результат
});
```
Теперь мы видим список, где большинство объектов пустые, но наши Vasya и Ivan там есть. Все работает!

