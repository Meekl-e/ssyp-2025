### Начинаем познавать клиент-серверные системы в технологиях .NET C#
Под рукой имеем dotnet-sdk версии 8 или более и каким-либо0 текстовым редактором, хорошим вариантом является специализированный редактор VisualStudioCode, но можно хоть Notepad. Многие имеют опыт пользования VisualStudio и поставленный VS-2022, им может быть удобно вместо редактора пользоваться им. Запускаем консоль, настраиваем место для работы, напр. D:\Home\dev, переходим в консоли туда. Создаем первый рабочий проект для обучения и пробы, напр. First. Переходим в него и выполняем в консоли команду 
```
dotnet new console
```
console - это шаблон, по которому создается новое приложение в виде проекта.иСмотрим что получилось. Появился один C# файл, один служебный файл First.csproj (он определяет проект) и одна служебная директория. Нас будет интересовать только C# файл и другие .cs файлы, которые Вы напишите в этой директории. Далее, нужно программу откомпилировать и исполнить. Это делается двумя командами:
```
dotnet build
dotnet run
```
Результат понятен - появление приветствия. Далее, можно потренировться реализовывать простые программы, для тех, кто не достаточно уверенно владеет C#, мастер предоставляет памятку по языку и основным функциям. Для подвинутых - есть документация на сайте http://learn.microsoft.com. Нас интересует документация (учебные материалы, описания, справочники) по C# и системе программирования ASP.NET. Пока можно не увлекаться чтением, мы будем пользоваться очень ограниченными средствами для решения нашей задачи. 

Теперь сделаем шаг в сторону построения целевой программной системы. Консольные приложения, которые мы опробывали, имеют много преимуществ, но есть и существенные недостатки. В частности, код программы должен находиться на компьютере пользователя. Это порождает неудобства смены версий, а главное, возможность поражеия кода вредоносными программами (вирусами, червями и др.). Поэтому наиболее рациональным решением для информационных систем, является размещение программного кода на одном компьютере - сервере. Тогда пользователь системы из своего браузера делает к серверу запросы, получает от сервера ответы, которые визуализируются браузером. Почти весь мир программных систем устроен так. Это называется клиент-серверная архитектура!

Теперь создадим простейшую систему с клиент-серверной (правильнее говорить клиент-сервисной) архитектурой. Это наиболее распространенный вариант web-приложение. Создадим еще одну пустую директорию, напр. Second и в ней запустим генерацию проекта по другому шаблону:
```
dotnet new web
```
Будет порожден другой проект. Пока не будем анализировать как он устроен, а просто его запустим
```
dotnet run
```
Программа откомпилировалась (сама запустила dotnet build), что-то выполнила и остановилась... Что случилось? Все нормально, так и должно быть. Программа (web-приложение) сформировала обработчик запросов и "повесила" обработчик на некоторый порт. Обратите внимание на выдачу приложения, оно сообщает что-то типа "Now listening on: http://localhost:5155". Это означает, что программа "слушает" запросы (request), направленные на указанный порт (порт может быть другой) и будет обрабатывать запрос когда он поступит. Это функция приложения "висеть", получать запрос, обрабатывать запрос, формировать ответ (response) и отправлять его назад, клиенту. Выглядит страшновато, но все достаточно просто. Чтобы получить результат работы приложения, надо сделать запрос. Запрос делается с помошью браузера. Мы в выдаче видели какой порт задействован приложением и теперь в браузер, в адресной строке, набираем:
```
http://localhost:5155/
```  
Или какой адрес был выдан. В браузере появится строчка типа: Hello World!. Что произошло? Браузер, по данной адресной строке выдал запрос на порт вашего же компьютера (localhost), приложение этот запрос приняло и ответило приветствием. На следующий запрос, будет тот же ответ. Опять все непонятно. Вам может казаться, что это все как-то у вам "крутится" в одной цепи обработки, но сейчас создано web-приложение и любой клиент, выпняющий запрос данному компьютеру по данному порту, будет получать такое же приветствие. Обработка запроса происходит быстро и непонятно, кадр в браузере сменился или нет. Пора разбираться в приложении и делать эксперименты. Как и в экспериментах с консольным приложением, нам понадобится редактор. В редакторе  загрузим C# код файла Program.cs, будет что-то типа:
```
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.MapGet("/", () => "Hello World!");
app.Run();
```
Не особенно разбираясь, просто заменим строку выдачи, напр. на выражение "Hello " + DateTime.Now

А как теперь (новое) приложение скомпилировать? Старое приложение по-прежнему "висит" в ожидании запроса. Надо сначала его убрать, т.е. завершить, что также освободит порт. А потом снова его запустить (не забудьте в редакторе сохранить изменения в файле). Завершение приложения делается через нажатие <Cntrl>C (контрол Це). Запустив снова приложение, мы не увидем в браузере изменения. А как же иначе? Ведь браузер получил ответ от прошлого запроса и "держит" его. Конечно, надо снова запросить. Нажав на браузере "крутилку" обновления, получим требуемое изменение. Понажимав, мы обнаружим, что зафиксированное время запроса изменяется. Можно такой же адрес ввести в другом браузере или в другом экземпляре браузера, наше приложение будет исправно выдавать приветствие с (новым) временем. 

Теперь проанализируем что у нас в коде программы и как это все работает. Во-первых, полезно знать формат и суть того запроса, который отправляется от клиента. Основная часть запроса, это адресная строка. Ее формат определен несложным стандартом, упрощенно это:
```
prot://domain:port/rest
```
здесь prot - буквы, обозначающие протокол, напр. http или ftp,
domain - доменное имя компьютера, напр. www.ibm.com, port = номер порта, к которому адресуется запрос, rest - (почти) произвольный набор символов в котором обычно имеются параметры запроса. Запрос http://localhost:5155/ соответствует этому формату, мы видим и протокол http и порт 5155. Браузер, посылая запрос не знает где находится компьютер-получатель. Это выявляет инфраструктура сети (DNS, ip-адреса и пр.), и сеть направляет запрос к нужному компьютеру и активирует нужны порт этого компьютера. На этом порту "висит" и "слушает" обработчик, который получает запрос и направляет его на обработку приложению. Приложение вырабатывает результат, в эксперименте - текстовую строку и отправляет его обратно клиенту. Клиент использует полученный результат. Все, это главное. 

Теперь еще раз постмотрим на приведенные 4 строчки программы приложения. Первые две строчки носят технический характер и нам не обязательно знать что они делают. Кстати, в данном случае, их можно объединить в одну. Четвертая строчка указывает, что подготовленный обработчик "вешается" на соответствующий порт. Главная тут третья строчка в которой указано, что на запрос Get с пустым rest, должна будет выполнена фунция, результат которой (вычисленный текст) отправляется в ответ, возвращаемый запрашивающему клиенту. 

Полезно знать также как назначается порт для обработки. Для приложения, порты задаются в файле launchSettings.json, детали нужно смотреть в документации. Но что важно, при установке на сервере, обычно используется порт 80, который является дефолтным для http и может не указываться в адресной строке. 

Следующий момент - как передать параметры из запроса в вычисление результата. Для этого, в технологии ASP.NET была разработана (непростая) технология Route, которую в Microsoft перевели как маршруты. Не вдаваясь в подробности и трудности этой технологии, рассмотрим простейшие, но нам нужные варианты. Итак, нам надо закодировать в остаточной части адресной строки параметры в виде пар имя-значение и извлечь эту информацию из оттуда. Очень традиционно параметры кодируют в следующем виде:
```
http://domain:port/part?id1=value1&id2=value2
``` 
Где в part кодируется что-то другое (об этом - потом), а id1, id2 - передаваемые параметры. Видимо это стандарт, потому что в формах HTML данные заполненной формы кодируются именно так. 

Добавим в нашу программу еще один обработчик маршрута:
```
// Запрос с параметрами, параметры участвуют в формировании ответа 
app.MapGet("/a", (HttpRequest request) => 
{
    var x = request.Query["x"];
    var y = request.Query["y"];
    return $"Hello {x} и {y}!";
});
// проверка: http://localhost:5167/a?x=1&y=qqq
```
при проверке работоспособности сервиса (приложения) выяснится, что на старый пустой запрос, ответ будет старым, но если использовать направление a, то ответ будет с использованными зачениями x и y. a здесь играет роль страницы или направления обработки. Важно осознать, что при получении запроса, сначала идет определение направления запроса, а потом применяется указанная для этого направления функция.  Некоторые другие моменты, связанные с программи, будут охарактеризованы позже.

Следующий момент, требующий управления, это формат результата. В рассмотренных примерах формат результата был простой (плоский) текст. В браузере мы его видим потому, что это один из форматов, которые визуализируется. Для браузера основной формат получения информации - это HTML. Добавляя еще обработчик:
```
// Выдача в формате HTML
app.MapGet("/ah", () => {
    return Results.Content("<h1>Test in HTML</h1>", "text/html");
});
```  
мы видим как просто превращать формат в HTML. Аналогично делается преобразование в XML и JSON.